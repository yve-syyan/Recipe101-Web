{"ast":null,"code":"// Licensed to the Software Freedom Conservancy (SFC) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The SFC licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n'use strict';\n/**\r\n * @fileoverview Defines WebDriver's logging system. The logging system is\r\n * broken into major components: local and remote logging.\r\n *\r\n * The local logging API, which is anchored by the {@linkplain Logger} class is\r\n * similar to Java's logging API. Loggers, retrieved by\r\n * {@linkplain #getLogger getLogger(name)}, use hierarchical, dot-delimited\r\n * namespaces (e.g. \"\" > \"webdriver\" > \"webdriver.logging\"). Recorded log\r\n * messages are represented by the {@linkplain Entry} class. You can capture log\r\n * records by {@linkplain Logger#addHandler attaching} a handler function to the\r\n * desired logger. For convenience, you can quickly enable logging to the\r\n * console by simply calling {@linkplain #installConsoleHandler\r\n * installConsoleHandler}.\r\n *\r\n * The [remote logging API](https://github.com/SeleniumHQ/selenium/wiki/Logging)\r\n * allows you to retrieve logs from a remote WebDriver server. This API uses the\r\n * {@link Preferences} class to define desired log levels prior to creating\r\n * a WebDriver session:\r\n *\r\n *     var prefs = new logging.Preferences();\r\n *     prefs.setLevel(logging.Type.BROWSER, logging.Level.DEBUG);\r\n *\r\n *     var caps = Capabilities.chrome();\r\n *     caps.setLoggingPrefs(prefs);\r\n *     // ...\r\n *\r\n * Remote log entries, also represented by the {@link Entry} class, may be\r\n * retrieved via {@link webdriver.WebDriver.Logs}:\r\n *\r\n *     driver.manage().logs().get(logging.Type.BROWSER)\r\n *         .then(function(entries) {\r\n *            entries.forEach(function(entry) {\r\n *              console.log('[%s] %s', entry.level.name, entry.message);\r\n *            });\r\n *         });\r\n *\r\n * **NOTE:** Only a few browsers support the remote logging API (notably\r\n * Firefox and Chrome). Firefox supports basic logging functionality, while\r\n * Chrome exposes robust\r\n * [performance logging](https://sites.google.com/a/chromium.org/chromedriver/logging)\r\n * options. Remote logging is still considered a non-standard feature, and the\r\n * APIs exposed by this module for it are non-frozen. This module will be\r\n * updated, possibly breaking backwards-compatibility, once logging is\r\n * officially defined by the\r\n * [W3C WebDriver spec](http://www.w3.org/TR/webdriver/).\r\n */\n\n/**\r\n * Defines a message level that may be used to control logging output.\r\n *\r\n * @final\r\n */\n\nclass Level {\n  /**\r\n   * @param {string} name the level's name.\r\n   * @param {number} level the level's numeric value.\r\n   */\n  constructor(name, level) {\n    if (level < 0) {\n      throw new TypeError('Level must be >= 0');\n    }\n    /** @private {string} */\n\n\n    this.name_ = name;\n    /** @private {number} */\n\n    this.value_ = level;\n  }\n  /** This logger's name. */\n\n\n  get name() {\n    return this.name_;\n  }\n  /** The numeric log level. */\n\n\n  get value() {\n    return this.value_;\n  }\n  /** @override */\n\n\n  toString() {\n    return this.name;\n  }\n\n}\n/**\r\n * Indicates no log messages should be recorded.\r\n * @const\r\n */\n\n\nLevel.OFF = new Level('OFF', Infinity);\n/**\r\n * Log messages with a level of `1000` or higher.\r\n * @const\r\n */\n\nLevel.SEVERE = new Level('SEVERE', 1000);\n/**\r\n * Log messages with a level of `900` or higher.\r\n * @const\r\n */\n\nLevel.WARNING = new Level('WARNING', 900);\n/**\r\n * Log messages with a level of `800` or higher.\r\n * @const\r\n */\n\nLevel.INFO = new Level('INFO', 800);\n/**\r\n * Log messages with a level of `700` or higher.\r\n * @const\r\n */\n\nLevel.DEBUG = new Level('DEBUG', 700);\n/**\r\n * Log messages with a level of `500` or higher.\r\n * @const\r\n */\n\nLevel.FINE = new Level('FINE', 500);\n/**\r\n * Log messages with a level of `400` or higher.\r\n * @const\r\n */\n\nLevel.FINER = new Level('FINER', 400);\n/**\r\n * Log messages with a level of `300` or higher.\r\n * @const\r\n */\n\nLevel.FINEST = new Level('FINEST', 300);\n/**\r\n * Indicates all log messages should be recorded.\r\n * @const\r\n */\n\nLevel.ALL = new Level('ALL', 0);\nconst ALL_LEVELS =\n/** !Set<Level> */\nnew Set([Level.OFF, Level.SEVERE, Level.WARNING, Level.INFO, Level.DEBUG, Level.FINE, Level.FINER, Level.FINEST, Level.ALL]);\nconst LEVELS_BY_NAME =\n/** !Map<string, !Level> */\nnew Map([[Level.OFF.name, Level.OFF], [Level.SEVERE.name, Level.SEVERE], [Level.WARNING.name, Level.WARNING], [Level.INFO.name, Level.INFO], [Level.DEBUG.name, Level.DEBUG], [Level.FINE.name, Level.FINE], [Level.FINER.name, Level.FINER], [Level.FINEST.name, Level.FINEST], [Level.ALL.name, Level.ALL]]);\n/**\r\n * Converts a level name or value to a {@link Level} value. If the name/value\r\n * is not recognized, {@link Level.ALL} will be returned.\r\n *\r\n * @param {(number|string)} nameOrValue The log level name, or value, to\r\n *     convert.\r\n * @return {!Level} The converted level.\r\n */\n\nfunction getLevel(nameOrValue) {\n  if (typeof nameOrValue === 'string') {\n    return LEVELS_BY_NAME.get(nameOrValue) || Level.ALL;\n  }\n\n  if (typeof nameOrValue !== 'number') {\n    throw new TypeError('not a string or number');\n  }\n\n  for (let level of ALL_LEVELS) {\n    if (nameOrValue >= level.value) {\n      return level;\n    }\n  }\n\n  return Level.ALL;\n}\n/**\r\n * Describes a single log entry.\r\n *\r\n * @final\r\n */\n\n\nclass Entry {\n  /**\r\n   * @param {(!Level|string|number)} level The entry level.\r\n   * @param {string} message The log message.\r\n   * @param {number=} opt_timestamp The time this entry was generated, in\r\n   *     milliseconds since 0:00:00, January 1, 1970 UTC. If omitted, the\r\n   *     current time will be used.\r\n   * @param {string=} opt_type The log type, if known.\r\n   */\n  constructor(level, message, opt_timestamp, opt_type) {\n    this.level = level instanceof Level ? level : getLevel(level);\n    this.message = message;\n    this.timestamp = typeof opt_timestamp === 'number' ? opt_timestamp : Date.now();\n    this.type = opt_type || '';\n  }\n  /**\r\n   * @return {{level: string, message: string, timestamp: number,\r\n   *           type: string}} The JSON representation of this entry.\r\n   */\n\n\n  toJSON() {\n    return {\n      'level': this.level.name,\n      'message': this.message,\n      'timestamp': this.timestamp,\n      'type': this.type\n    };\n  }\n\n}\n/**\r\n * An object used to log debugging messages. Loggers use a hierarchical,\r\n * dot-separated naming scheme. For instance, \"foo\" is considered the parent of\r\n * the \"foo.bar\" and an ancestor of \"foo.bar.baz\".\r\n *\r\n * Each logger may be assigned a {@linkplain #setLevel log level}, which\r\n * controls which level of messages will be reported to the\r\n * {@linkplain #addHandler handlers} attached to this instance. If a log level\r\n * is not explicitly set on a logger, it will inherit its parent.\r\n *\r\n * This class should never be directly instantiated. Instead, users should\r\n * obtain logger references using the {@linkplain ./logging.getLogger()\r\n * getLogger()} function.\r\n *\r\n * @final\r\n */\n\n\nclass Logger {\n  /**\r\n   * @param {string} name the name of this logger.\r\n   * @param {Level=} opt_level the initial level for this logger.\r\n   */\n  constructor(name, opt_level) {\n    /** @private {string} */\n    this.name_ = name;\n    /** @private {Level} */\n\n    this.level_ = opt_level || null;\n    /** @private {Logger} */\n\n    this.parent_ = null;\n    /** @private {Set<function(!Entry)>} */\n\n    this.handlers_ = null;\n  }\n  /** @return {string} the name of this logger. */\n\n\n  getName() {\n    return this.name_;\n  }\n  /**\r\n   * @param {Level} level the new level for this logger, or `null` if the logger\r\n   *     should inherit its level from its parent logger.\r\n   */\n\n\n  setLevel(level) {\n    this.level_ = level;\n  }\n  /** @return {Level} the log level for this logger. */\n\n\n  getLevel() {\n    return this.level_;\n  }\n  /**\r\n   * @return {!Level} the effective level for this logger.\r\n   */\n\n\n  getEffectiveLevel() {\n    let logger = this;\n    let level;\n\n    do {\n      level = logger.level_;\n      logger = logger.parent_;\n    } while (logger && !level);\n\n    return level || Level.OFF;\n  }\n  /**\r\n   * @param {!Level} level the level to check.\r\n   * @return {boolean} whether messages recorded at the given level are loggable\r\n   *     by this instance.\r\n   */\n\n\n  isLoggable(level) {\n    return level.value !== Level.OFF.value && level.value >= this.getEffectiveLevel().value;\n  }\n  /**\r\n   * Adds a handler to this logger. The handler will be invoked for each message\r\n   * logged with this instance, or any of its descendants.\r\n   *\r\n   * @param {function(!Entry)} handler the handler to add.\r\n   */\n\n\n  addHandler(handler) {\n    if (!this.handlers_) {\n      this.handlers_ = new Set();\n    }\n\n    this.handlers_.add(handler);\n  }\n  /**\r\n   * Removes a handler from this logger.\r\n   *\r\n   * @param {function(!Entry)} handler the handler to remove.\r\n   * @return {boolean} whether a handler was successfully removed.\r\n   */\n\n\n  removeHandler(handler) {\n    if (!this.handlers_) {\n      return false;\n    }\n\n    return this.handlers_.delete(handler);\n  }\n  /**\r\n   * Logs a message at the given level. The message may be defined as a string\r\n   * or as a function that will return the message. If a function is provided,\r\n   * it will only be invoked if this logger's\r\n   * {@linkplain #getEffectiveLevel() effective log level} includes the given\r\n   * `level`.\r\n   *\r\n   * @param {!Level} level the level at which to log the message.\r\n   * @param {(string|function(): string)} loggable the message to log, or a\r\n   *     function that will return the message.\r\n   */\n\n\n  log(level, loggable) {\n    if (!this.isLoggable(level)) {\n      return;\n    }\n\n    let message = '[' + this.name_ + '] ' + (typeof loggable === 'function' ? loggable() : loggable);\n    let entry = new Entry(level, message, Date.now());\n\n    for (let logger = this; !!logger; logger = logger.parent_) {\n      if (logger.handlers_) {\n        for (let handler of logger.handlers_) {\n          handler(entry);\n        }\n      }\n    }\n  }\n  /**\r\n   * Logs a message at the {@link Level.SEVERE} log level.\r\n   * @param {(string|function(): string)} loggable the message to log, or a\r\n   *     function that will return the message.\r\n   */\n\n\n  severe(loggable) {\n    this.log(Level.SEVERE, loggable);\n  }\n  /**\r\n   * Logs a message at the {@link Level.WARNING} log level.\r\n   * @param {(string|function(): string)} loggable the message to log, or a\r\n   *     function that will return the message.\r\n   */\n\n\n  warning(loggable) {\n    this.log(Level.WARNING, loggable);\n  }\n  /**\r\n   * Logs a message at the {@link Level.INFO} log level.\r\n   * @param {(string|function(): string)} loggable the message to log, or a\r\n   *     function that will return the message.\r\n   */\n\n\n  info(loggable) {\n    this.log(Level.INFO, loggable);\n  }\n  /**\r\n   * Logs a message at the {@link Level.DEBUG} log level.\r\n   * @param {(string|function(): string)} loggable the message to log, or a\r\n   *     function that will return the message.\r\n   */\n\n\n  debug(loggable) {\n    this.log(Level.DEBUG, loggable);\n  }\n  /**\r\n   * Logs a message at the {@link Level.FINE} log level.\r\n   * @param {(string|function(): string)} loggable the message to log, or a\r\n   *     function that will return the message.\r\n   */\n\n\n  fine(loggable) {\n    this.log(Level.FINE, loggable);\n  }\n  /**\r\n   * Logs a message at the {@link Level.FINER} log level.\r\n   * @param {(string|function(): string)} loggable the message to log, or a\r\n   *     function that will return the message.\r\n   */\n\n\n  finer(loggable) {\n    this.log(Level.FINER, loggable);\n  }\n  /**\r\n   * Logs a message at the {@link Level.FINEST} log level.\r\n   * @param {(string|function(): string)} loggable the message to log, or a\r\n   *     function that will return the message.\r\n   */\n\n\n  finest(loggable) {\n    this.log(Level.FINEST, loggable);\n  }\n\n}\n/**\r\n * Maintains a collection of loggers.\r\n *\r\n * @final\r\n */\n\n\nclass LogManager {\n  constructor() {\n    /** @private {!Map<string, !Logger>} */\n    this.loggers_ = new Map();\n    this.root_ = new Logger('', Level.OFF);\n  }\n  /**\r\n   * Retrieves a named logger, creating it in the process. This function will\r\n   * implicitly create the requested logger, and any of its parents, if they\r\n   * do not yet exist.\r\n   *\r\n   * @param {string} name the logger's name.\r\n   * @return {!Logger} the requested logger.\r\n   */\n\n\n  getLogger(name) {\n    if (!name) {\n      return this.root_;\n    }\n\n    let parent = this.root_;\n\n    for (let i = name.indexOf('.'); i != -1; i = name.indexOf('.', i + 1)) {\n      let parentName = name.substr(0, i);\n      parent = this.createLogger_(parentName, parent);\n    }\n\n    return this.createLogger_(name, parent);\n  }\n  /**\r\n   * Creates a new logger.\r\n   *\r\n   * @param {string} name the logger's name.\r\n   * @param {!Logger} parent the logger's parent.\r\n   * @return {!Logger} the new logger.\r\n   * @private\r\n   */\n\n\n  createLogger_(name, parent) {\n    if (this.loggers_.has(name)) {\n      return (\n        /** @type {!Logger} */\n        this.loggers_.get(name)\n      );\n    }\n\n    let logger = new Logger(name, null);\n    logger.parent_ = parent;\n    this.loggers_.set(name, logger);\n    return logger;\n  }\n\n}\n\nconst logManager = new LogManager();\n/**\r\n * Retrieves a named logger, creating it in the process. This function will\r\n * implicitly create the requested logger, and any of its parents, if they\r\n * do not yet exist.\r\n *\r\n * The log level will be unspecified for newly created loggers. Use\r\n * {@link Logger#setLevel(level)} to explicitly set a level.\r\n *\r\n * @param {string} name the logger's name.\r\n * @return {!Logger} the requested logger.\r\n */\n\nfunction getLogger(name) {\n  return logManager.getLogger(name);\n}\n/**\r\n * Pads a number to ensure it has a minimum of two digits.\r\n *\r\n * @param {number} n the number to be padded.\r\n * @return {string} the padded number.\r\n */\n\n\nfunction pad(n) {\n  if (n >= 10) {\n    return '' + n;\n  } else {\n    return '0' + n;\n  }\n}\n/**\r\n * Logs all messages to the Console API.\r\n * @param {!Entry} entry the entry to log.\r\n */\n\n\nfunction consoleHandler(entry) {\n  if (typeof console === 'undefined' || !console) {\n    return;\n  }\n\n  var timestamp = new Date(entry.timestamp);\n  var msg = '[' + timestamp.getUTCFullYear() + '-' + pad(timestamp.getUTCMonth() + 1) + '-' + pad(timestamp.getUTCDate()) + 'T' + pad(timestamp.getUTCHours()) + ':' + pad(timestamp.getUTCMinutes()) + ':' + pad(timestamp.getUTCSeconds()) + 'Z] ' + '[' + entry.level.name + '] ' + entry.message;\n  var level = entry.level.value;\n\n  if (level >= Level.SEVERE.value) {\n    console.error(msg);\n  } else if (level >= Level.WARNING.value) {\n    console.warn(msg);\n  } else {\n    console.log(msg);\n  }\n}\n/**\r\n * Adds the console handler to the given logger. The console handler will log\r\n * all messages using the JavaScript Console API.\r\n *\r\n * @param {Logger=} opt_logger The logger to add the handler to; defaults\r\n *     to the root logger.\r\n */\n\n\nfunction addConsoleHandler(opt_logger) {\n  let logger = opt_logger || logManager.root_;\n  logger.addHandler(consoleHandler);\n}\n/**\r\n * Removes the console log handler from the given logger.\r\n *\r\n * @param {Logger=} opt_logger The logger to remove the handler from; defaults\r\n *     to the root logger.\r\n * @see exports.addConsoleHandler\r\n */\n\n\nfunction removeConsoleHandler(opt_logger) {\n  let logger = opt_logger || logManager.root_;\n  logger.removeHandler(consoleHandler);\n}\n/**\r\n * Installs the console log handler on the root logger.\r\n */\n\n\nfunction installConsoleHandler() {\n  addConsoleHandler(logManager.root_);\n}\n/**\r\n * Common log types.\r\n * @enum {string}\r\n */\n\n\nconst Type = {\n  /** Logs originating from the browser. */\n  BROWSER: 'browser',\n\n  /** Logs from a WebDriver client. */\n  CLIENT: 'client',\n\n  /** Logs from a WebDriver implementation. */\n  DRIVER: 'driver',\n\n  /** Logs related to performance. */\n  PERFORMANCE: 'performance',\n\n  /** Logs from the remote server. */\n  SERVER: 'server'\n};\n/**\r\n * Describes the log preferences for a WebDriver session.\r\n *\r\n * @final\r\n */\n\nclass Preferences {\n  constructor() {\n    /** @private {!Map<string, !Level>} */\n    this.prefs_ = new Map();\n  }\n  /**\r\n   * Sets the desired logging level for a particular log type.\r\n   * @param {(string|Type)} type The log type.\r\n   * @param {(!Level|string|number)} level The desired log level.\r\n   * @throws {TypeError} if `type` is not a `string`.\r\n   */\n\n\n  setLevel(type, level) {\n    if (typeof type !== 'string') {\n      throw TypeError('specified log type is not a string: ' + typeof type);\n    }\n\n    this.prefs_.set(type, level instanceof Level ? level : getLevel(level));\n  }\n  /**\r\n   * Converts this instance to its JSON representation.\r\n   * @return {!Object<string, string>} The JSON representation of this set of\r\n   *     preferences.\r\n   */\n\n\n  toJSON() {\n    let json = {};\n\n    for (let key of this.prefs_.keys()) {\n      json[key] = this.prefs_.get(key).name;\n    }\n\n    return json;\n  }\n\n} // PUBLIC API\n\n\nmodule.exports = {\n  Entry: Entry,\n  Level: Level,\n  LogManager: LogManager,\n  Logger: Logger,\n  Preferences: Preferences,\n  Type: Type,\n  addConsoleHandler: addConsoleHandler,\n  getLevel: getLevel,\n  getLogger: getLogger,\n  installConsoleHandler: installConsoleHandler,\n  removeConsoleHandler: removeConsoleHandler\n};","map":{"version":3,"sources":["C:/Users/lepan/Desktop/CIS550-Project/final project/client/node_modules/selenium-webdriver/lib/logging.js"],"names":["Level","constructor","name","level","TypeError","name_","value_","value","toString","OFF","Infinity","SEVERE","WARNING","INFO","DEBUG","FINE","FINER","FINEST","ALL","ALL_LEVELS","Set","LEVELS_BY_NAME","Map","getLevel","nameOrValue","get","Entry","message","opt_timestamp","opt_type","timestamp","Date","now","type","toJSON","Logger","opt_level","level_","parent_","handlers_","getName","setLevel","getEffectiveLevel","logger","isLoggable","addHandler","handler","add","removeHandler","delete","log","loggable","entry","severe","warning","info","debug","fine","finer","finest","LogManager","loggers_","root_","getLogger","parent","i","indexOf","parentName","substr","createLogger_","has","set","logManager","pad","n","consoleHandler","console","msg","getUTCFullYear","getUTCMonth","getUTCDate","getUTCHours","getUTCMinutes","getUTCSeconds","error","warn","addConsoleHandler","opt_logger","removeConsoleHandler","installConsoleHandler","Type","BROWSER","CLIENT","DRIVER","PERFORMANCE","SERVER","Preferences","prefs_","json","key","keys","module","exports"],"mappings":"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","sourcesContent":["// Licensed to the Software Freedom Conservancy (SFC) under one\r\n// or more contributor license agreements.  See the NOTICE file\r\n// distributed with this work for additional information\r\n// regarding copyright ownership.  The SFC licenses this file\r\n// to you under the Apache License, Version 2.0 (the\r\n// \"License\"); you may not use this file except in compliance\r\n// with the License.  You may obtain a copy of the License at\r\n//\r\n//   http://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n// Unless required by applicable law or agreed to in writing,\r\n// software distributed under the License is distributed on an\r\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n// KIND, either express or implied.  See the License for the\r\n// specific language governing permissions and limitations\r\n// under the License.\r\n\r\n'use strict';\r\n\r\n/**\r\n * @fileoverview Defines WebDriver's logging system. The logging system is\r\n * broken into major components: local and remote logging.\r\n *\r\n * The local logging API, which is anchored by the {@linkplain Logger} class is\r\n * similar to Java's logging API. Loggers, retrieved by\r\n * {@linkplain #getLogger getLogger(name)}, use hierarchical, dot-delimited\r\n * namespaces (e.g. \"\" > \"webdriver\" > \"webdriver.logging\"). Recorded log\r\n * messages are represented by the {@linkplain Entry} class. You can capture log\r\n * records by {@linkplain Logger#addHandler attaching} a handler function to the\r\n * desired logger. For convenience, you can quickly enable logging to the\r\n * console by simply calling {@linkplain #installConsoleHandler\r\n * installConsoleHandler}.\r\n *\r\n * The [remote logging API](https://github.com/SeleniumHQ/selenium/wiki/Logging)\r\n * allows you to retrieve logs from a remote WebDriver server. This API uses the\r\n * {@link Preferences} class to define desired log levels prior to creating\r\n * a WebDriver session:\r\n *\r\n *     var prefs = new logging.Preferences();\r\n *     prefs.setLevel(logging.Type.BROWSER, logging.Level.DEBUG);\r\n *\r\n *     var caps = Capabilities.chrome();\r\n *     caps.setLoggingPrefs(prefs);\r\n *     // ...\r\n *\r\n * Remote log entries, also represented by the {@link Entry} class, may be\r\n * retrieved via {@link webdriver.WebDriver.Logs}:\r\n *\r\n *     driver.manage().logs().get(logging.Type.BROWSER)\r\n *         .then(function(entries) {\r\n *            entries.forEach(function(entry) {\r\n *              console.log('[%s] %s', entry.level.name, entry.message);\r\n *            });\r\n *         });\r\n *\r\n * **NOTE:** Only a few browsers support the remote logging API (notably\r\n * Firefox and Chrome). Firefox supports basic logging functionality, while\r\n * Chrome exposes robust\r\n * [performance logging](https://sites.google.com/a/chromium.org/chromedriver/logging)\r\n * options. Remote logging is still considered a non-standard feature, and the\r\n * APIs exposed by this module for it are non-frozen. This module will be\r\n * updated, possibly breaking backwards-compatibility, once logging is\r\n * officially defined by the\r\n * [W3C WebDriver spec](http://www.w3.org/TR/webdriver/).\r\n */\r\n\r\n/**\r\n * Defines a message level that may be used to control logging output.\r\n *\r\n * @final\r\n */\r\nclass Level {\r\n  /**\r\n   * @param {string} name the level's name.\r\n   * @param {number} level the level's numeric value.\r\n   */\r\n  constructor(name, level) {\r\n    if (level < 0) {\r\n      throw new TypeError('Level must be >= 0');\r\n    }\r\n\r\n    /** @private {string} */\r\n    this.name_ = name;\r\n\r\n    /** @private {number} */\r\n    this.value_ = level;\r\n  }\r\n\r\n  /** This logger's name. */\r\n  get name() {\r\n    return this.name_;\r\n  }\r\n\r\n  /** The numeric log level. */\r\n  get value() {\r\n    return this.value_;\r\n  }\r\n\r\n  /** @override */\r\n  toString() {\r\n    return this.name;\r\n  }\r\n}\r\n\r\n/**\r\n * Indicates no log messages should be recorded.\r\n * @const\r\n */\r\nLevel.OFF = new Level('OFF', Infinity);\r\n\r\n\r\n/**\r\n * Log messages with a level of `1000` or higher.\r\n * @const\r\n */\r\nLevel.SEVERE = new Level('SEVERE', 1000);\r\n\r\n\r\n/**\r\n * Log messages with a level of `900` or higher.\r\n * @const\r\n */\r\nLevel.WARNING = new Level('WARNING', 900);\r\n\r\n\r\n/**\r\n * Log messages with a level of `800` or higher.\r\n * @const\r\n */\r\nLevel.INFO = new Level('INFO', 800);\r\n\r\n\r\n/**\r\n * Log messages with a level of `700` or higher.\r\n * @const\r\n */\r\nLevel.DEBUG = new Level('DEBUG', 700);\r\n\r\n\r\n/**\r\n * Log messages with a level of `500` or higher.\r\n * @const\r\n */\r\nLevel.FINE = new Level('FINE', 500);\r\n\r\n\r\n/**\r\n * Log messages with a level of `400` or higher.\r\n * @const\r\n */\r\nLevel.FINER = new Level('FINER', 400);\r\n\r\n\r\n/**\r\n * Log messages with a level of `300` or higher.\r\n * @const\r\n */\r\nLevel.FINEST = new Level('FINEST', 300);\r\n\r\n\r\n/**\r\n * Indicates all log messages should be recorded.\r\n * @const\r\n */\r\nLevel.ALL = new Level('ALL', 0);\r\n\r\n\r\nconst ALL_LEVELS = /** !Set<Level> */new Set([\r\n  Level.OFF,\r\n  Level.SEVERE,\r\n  Level.WARNING,\r\n  Level.INFO,\r\n  Level.DEBUG,\r\n  Level.FINE,\r\n  Level.FINER,\r\n  Level.FINEST,\r\n  Level.ALL\r\n]);\r\n\r\n\r\nconst LEVELS_BY_NAME = /** !Map<string, !Level> */ new Map([\r\n  [Level.OFF.name, Level.OFF],\r\n  [Level.SEVERE.name, Level.SEVERE],\r\n  [Level.WARNING.name, Level.WARNING],\r\n  [Level.INFO.name, Level.INFO],\r\n  [Level.DEBUG.name, Level.DEBUG],\r\n  [Level.FINE.name, Level.FINE],\r\n  [Level.FINER.name, Level.FINER],\r\n  [Level.FINEST.name, Level.FINEST],\r\n  [Level.ALL.name, Level.ALL]\r\n]);\r\n\r\n\r\n/**\r\n * Converts a level name or value to a {@link Level} value. If the name/value\r\n * is not recognized, {@link Level.ALL} will be returned.\r\n *\r\n * @param {(number|string)} nameOrValue The log level name, or value, to\r\n *     convert.\r\n * @return {!Level} The converted level.\r\n */\r\nfunction getLevel(nameOrValue) {\r\n  if (typeof nameOrValue === 'string') {\r\n    return LEVELS_BY_NAME.get(nameOrValue) || Level.ALL;\r\n  }\r\n  if (typeof nameOrValue !== 'number') {\r\n    throw new TypeError('not a string or number');\r\n  }\r\n  for (let level of ALL_LEVELS) {\r\n    if (nameOrValue >= level.value) {\r\n      return level;\r\n    }\r\n  }\r\n  return Level.ALL;\r\n}\r\n\r\n\r\n/**\r\n * Describes a single log entry.\r\n *\r\n * @final\r\n */\r\nclass Entry {\r\n  /**\r\n   * @param {(!Level|string|number)} level The entry level.\r\n   * @param {string} message The log message.\r\n   * @param {number=} opt_timestamp The time this entry was generated, in\r\n   *     milliseconds since 0:00:00, January 1, 1970 UTC. If omitted, the\r\n   *     current time will be used.\r\n   * @param {string=} opt_type The log type, if known.\r\n   */\r\n  constructor(level, message, opt_timestamp, opt_type) {\r\n    this.level = level instanceof Level ? level : getLevel(level);\r\n    this.message = message;\r\n    this.timestamp =\r\n        typeof opt_timestamp === 'number' ? opt_timestamp : Date.now();\r\n    this.type = opt_type || '';\r\n  }\r\n\r\n  /**\r\n   * @return {{level: string, message: string, timestamp: number,\r\n   *           type: string}} The JSON representation of this entry.\r\n   */\r\n  toJSON() {\r\n    return {\r\n      'level': this.level.name,\r\n      'message': this.message,\r\n      'timestamp': this.timestamp,\r\n      'type': this.type\r\n    };\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * An object used to log debugging messages. Loggers use a hierarchical,\r\n * dot-separated naming scheme. For instance, \"foo\" is considered the parent of\r\n * the \"foo.bar\" and an ancestor of \"foo.bar.baz\".\r\n *\r\n * Each logger may be assigned a {@linkplain #setLevel log level}, which\r\n * controls which level of messages will be reported to the\r\n * {@linkplain #addHandler handlers} attached to this instance. If a log level\r\n * is not explicitly set on a logger, it will inherit its parent.\r\n *\r\n * This class should never be directly instantiated. Instead, users should\r\n * obtain logger references using the {@linkplain ./logging.getLogger()\r\n * getLogger()} function.\r\n *\r\n * @final\r\n */\r\nclass Logger {\r\n  /**\r\n   * @param {string} name the name of this logger.\r\n   * @param {Level=} opt_level the initial level for this logger.\r\n   */\r\n  constructor(name, opt_level) {\r\n    /** @private {string} */\r\n    this.name_ = name;\r\n\r\n    /** @private {Level} */\r\n    this.level_ = opt_level || null;\r\n\r\n    /** @private {Logger} */\r\n    this.parent_ = null;\r\n\r\n    /** @private {Set<function(!Entry)>} */\r\n    this.handlers_ = null;\r\n  }\r\n\r\n  /** @return {string} the name of this logger. */\r\n  getName() {\r\n    return this.name_;\r\n  }\r\n\r\n  /**\r\n   * @param {Level} level the new level for this logger, or `null` if the logger\r\n   *     should inherit its level from its parent logger.\r\n   */\r\n  setLevel(level) {\r\n    this.level_ = level;\r\n  }\r\n\r\n  /** @return {Level} the log level for this logger. */\r\n  getLevel() {\r\n    return this.level_;\r\n  }\r\n\r\n  /**\r\n   * @return {!Level} the effective level for this logger.\r\n   */\r\n  getEffectiveLevel() {\r\n    let logger = this;\r\n    let level;\r\n    do {\r\n      level = logger.level_;\r\n      logger = logger.parent_;\r\n    } while (logger && !level);\r\n    return level || Level.OFF;\r\n  }\r\n\r\n  /**\r\n   * @param {!Level} level the level to check.\r\n   * @return {boolean} whether messages recorded at the given level are loggable\r\n   *     by this instance.\r\n   */\r\n  isLoggable(level) {\r\n    return level.value !== Level.OFF.value\r\n        && level.value >= this.getEffectiveLevel().value;\r\n  }\r\n\r\n  /**\r\n   * Adds a handler to this logger. The handler will be invoked for each message\r\n   * logged with this instance, or any of its descendants.\r\n   *\r\n   * @param {function(!Entry)} handler the handler to add.\r\n   */\r\n  addHandler(handler) {\r\n    if (!this.handlers_) {\r\n      this.handlers_ = new Set;\r\n    }\r\n    this.handlers_.add(handler);\r\n  }\r\n\r\n  /**\r\n   * Removes a handler from this logger.\r\n   *\r\n   * @param {function(!Entry)} handler the handler to remove.\r\n   * @return {boolean} whether a handler was successfully removed.\r\n   */\r\n  removeHandler(handler) {\r\n    if (!this.handlers_) {\r\n      return false;\r\n    }\r\n    return this.handlers_.delete(handler);\r\n  }\r\n\r\n  /**\r\n   * Logs a message at the given level. The message may be defined as a string\r\n   * or as a function that will return the message. If a function is provided,\r\n   * it will only be invoked if this logger's\r\n   * {@linkplain #getEffectiveLevel() effective log level} includes the given\r\n   * `level`.\r\n   *\r\n   * @param {!Level} level the level at which to log the message.\r\n   * @param {(string|function(): string)} loggable the message to log, or a\r\n   *     function that will return the message.\r\n   */\r\n  log(level, loggable) {\r\n    if (!this.isLoggable(level)) {\r\n      return;\r\n    }\r\n    let message = '[' + this.name_ + '] '\r\n        + (typeof loggable === 'function' ? loggable() : loggable);\r\n    let entry = new Entry(level, message, Date.now());\r\n    for (let logger = this; !!logger; logger = logger.parent_) {\r\n      if (logger.handlers_) {\r\n        for (let handler of logger.handlers_) {\r\n          handler(entry);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Logs a message at the {@link Level.SEVERE} log level.\r\n   * @param {(string|function(): string)} loggable the message to log, or a\r\n   *     function that will return the message.\r\n   */\r\n  severe(loggable) {\r\n    this.log(Level.SEVERE, loggable);\r\n  }\r\n\r\n  /**\r\n   * Logs a message at the {@link Level.WARNING} log level.\r\n   * @param {(string|function(): string)} loggable the message to log, or a\r\n   *     function that will return the message.\r\n   */\r\n  warning(loggable) {\r\n    this.log(Level.WARNING, loggable);\r\n  }\r\n\r\n  /**\r\n   * Logs a message at the {@link Level.INFO} log level.\r\n   * @param {(string|function(): string)} loggable the message to log, or a\r\n   *     function that will return the message.\r\n   */\r\n  info(loggable) {\r\n    this.log(Level.INFO, loggable);\r\n  }\r\n\r\n  /**\r\n   * Logs a message at the {@link Level.DEBUG} log level.\r\n   * @param {(string|function(): string)} loggable the message to log, or a\r\n   *     function that will return the message.\r\n   */\r\n  debug(loggable) {\r\n    this.log(Level.DEBUG, loggable);\r\n  }\r\n\r\n  /**\r\n   * Logs a message at the {@link Level.FINE} log level.\r\n   * @param {(string|function(): string)} loggable the message to log, or a\r\n   *     function that will return the message.\r\n   */\r\n  fine(loggable) {\r\n    this.log(Level.FINE, loggable);\r\n  }\r\n\r\n  /**\r\n   * Logs a message at the {@link Level.FINER} log level.\r\n   * @param {(string|function(): string)} loggable the message to log, or a\r\n   *     function that will return the message.\r\n   */\r\n  finer(loggable) {\r\n    this.log(Level.FINER, loggable);\r\n  }\r\n\r\n  /**\r\n   * Logs a message at the {@link Level.FINEST} log level.\r\n   * @param {(string|function(): string)} loggable the message to log, or a\r\n   *     function that will return the message.\r\n   */\r\n  finest(loggable) {\r\n    this.log(Level.FINEST, loggable);\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * Maintains a collection of loggers.\r\n *\r\n * @final\r\n */\r\nclass LogManager {\r\n  constructor() {\r\n    /** @private {!Map<string, !Logger>} */\r\n    this.loggers_ = new Map;\r\n    this.root_ = new Logger('', Level.OFF);\r\n  }\r\n\r\n  /**\r\n   * Retrieves a named logger, creating it in the process. This function will\r\n   * implicitly create the requested logger, and any of its parents, if they\r\n   * do not yet exist.\r\n   *\r\n   * @param {string} name the logger's name.\r\n   * @return {!Logger} the requested logger.\r\n   */\r\n  getLogger(name) {\r\n    if (!name) {\r\n      return this.root_;\r\n    }\r\n    let parent = this.root_;\r\n    for (let i = name.indexOf('.'); i != -1; i = name.indexOf('.', i + 1)) {\r\n      let parentName = name.substr(0, i);\r\n      parent = this.createLogger_(parentName, parent);\r\n    }\r\n    return this.createLogger_(name, parent);\r\n  }\r\n\r\n  /**\r\n   * Creates a new logger.\r\n   *\r\n   * @param {string} name the logger's name.\r\n   * @param {!Logger} parent the logger's parent.\r\n   * @return {!Logger} the new logger.\r\n   * @private\r\n   */\r\n  createLogger_(name, parent) {\r\n    if (this.loggers_.has(name)) {\r\n      return /** @type {!Logger} */(this.loggers_.get(name));\r\n    }\r\n    let logger = new Logger(name, null);\r\n    logger.parent_ = parent;\r\n    this.loggers_.set(name, logger);\r\n    return logger;\r\n  }\r\n}\r\n\r\n\r\nconst logManager = new LogManager;\r\n\r\n\r\n/**\r\n * Retrieves a named logger, creating it in the process. This function will\r\n * implicitly create the requested logger, and any of its parents, if they\r\n * do not yet exist.\r\n *\r\n * The log level will be unspecified for newly created loggers. Use\r\n * {@link Logger#setLevel(level)} to explicitly set a level.\r\n *\r\n * @param {string} name the logger's name.\r\n * @return {!Logger} the requested logger.\r\n */\r\nfunction getLogger(name) {\r\n  return logManager.getLogger(name);\r\n}\r\n\r\n\r\n/**\r\n * Pads a number to ensure it has a minimum of two digits.\r\n *\r\n * @param {number} n the number to be padded.\r\n * @return {string} the padded number.\r\n */\r\nfunction pad(n) {\r\n  if (n >= 10) {\r\n    return '' + n;\r\n  } else {\r\n    return '0' + n;\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * Logs all messages to the Console API.\r\n * @param {!Entry} entry the entry to log.\r\n */\r\nfunction consoleHandler(entry) {\r\n  if (typeof console === 'undefined' || !console) {\r\n    return;\r\n  }\r\n\r\n  var timestamp = new Date(entry.timestamp);\r\n  var msg =\r\n      '[' + timestamp.getUTCFullYear() + '-' +\r\n      pad(timestamp.getUTCMonth() + 1) + '-' +\r\n      pad(timestamp.getUTCDate()) + 'T' +\r\n      pad(timestamp.getUTCHours()) + ':' +\r\n      pad(timestamp.getUTCMinutes()) + ':' +\r\n      pad(timestamp.getUTCSeconds()) + 'Z] ' +\r\n      '[' + entry.level.name + '] ' +\r\n      entry.message;\r\n\r\n  var level = entry.level.value;\r\n  if (level >= Level.SEVERE.value) {\r\n    console.error(msg);\r\n  } else if (level >= Level.WARNING.value) {\r\n    console.warn(msg);\r\n  } else {\r\n    console.log(msg);\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * Adds the console handler to the given logger. The console handler will log\r\n * all messages using the JavaScript Console API.\r\n *\r\n * @param {Logger=} opt_logger The logger to add the handler to; defaults\r\n *     to the root logger.\r\n */\r\nfunction addConsoleHandler(opt_logger) {\r\n  let logger = opt_logger || logManager.root_;\r\n  logger.addHandler(consoleHandler);\r\n}\r\n\r\n\r\n/**\r\n * Removes the console log handler from the given logger.\r\n *\r\n * @param {Logger=} opt_logger The logger to remove the handler from; defaults\r\n *     to the root logger.\r\n * @see exports.addConsoleHandler\r\n */\r\nfunction removeConsoleHandler(opt_logger) {\r\n  let logger = opt_logger || logManager.root_;\r\n  logger.removeHandler(consoleHandler);\r\n}\r\n\r\n\r\n/**\r\n * Installs the console log handler on the root logger.\r\n */\r\nfunction installConsoleHandler() {\r\n  addConsoleHandler(logManager.root_);\r\n}\r\n\r\n\r\n/**\r\n * Common log types.\r\n * @enum {string}\r\n */\r\nconst Type = {\r\n  /** Logs originating from the browser. */\r\n  BROWSER: 'browser',\r\n  /** Logs from a WebDriver client. */\r\n  CLIENT: 'client',\r\n  /** Logs from a WebDriver implementation. */\r\n  DRIVER: 'driver',\r\n  /** Logs related to performance. */\r\n  PERFORMANCE: 'performance',\r\n  /** Logs from the remote server. */\r\n  SERVER: 'server'\r\n};\r\n\r\n\r\n/**\r\n * Describes the log preferences for a WebDriver session.\r\n *\r\n * @final\r\n */\r\nclass Preferences {\r\n  constructor() {\r\n    /** @private {!Map<string, !Level>} */\r\n    this.prefs_ = new Map;\r\n  }\r\n\r\n  /**\r\n   * Sets the desired logging level for a particular log type.\r\n   * @param {(string|Type)} type The log type.\r\n   * @param {(!Level|string|number)} level The desired log level.\r\n   * @throws {TypeError} if `type` is not a `string`.\r\n   */\r\n  setLevel(type, level) {\r\n    if (typeof type !== 'string') {\r\n      throw TypeError('specified log type is not a string: ' + typeof type);\r\n    }\r\n    this.prefs_.set(type, level instanceof Level ? level : getLevel(level));\r\n  }\r\n\r\n  /**\r\n   * Converts this instance to its JSON representation.\r\n   * @return {!Object<string, string>} The JSON representation of this set of\r\n   *     preferences.\r\n   */\r\n  toJSON() {\r\n    let json = {};\r\n    for (let key of this.prefs_.keys()) {\r\n      json[key] = this.prefs_.get(key).name;\r\n    }\r\n    return json;\r\n  }\r\n}\r\n\r\n\r\n// PUBLIC API\r\n\r\n\r\nmodule.exports = {\r\n  Entry: Entry,\r\n  Level: Level,\r\n  LogManager: LogManager,\r\n  Logger: Logger,\r\n  Preferences: Preferences,\r\n  Type: Type,\r\n  addConsoleHandler: addConsoleHandler,\r\n  getLevel: getLevel,\r\n  getLogger: getLogger,\r\n  installConsoleHandler: installConsoleHandler,\r\n  removeConsoleHandler: removeConsoleHandler\r\n};\r\n"]},"metadata":{},"sourceType":"script"}