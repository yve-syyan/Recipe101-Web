{"ast":null,"code":"/**\r\n * Copyright (c) 2013-present, Facebook, Inc.\r\n * All rights reserved.\r\n *\r\n * This source code is licensed under the BSD-style license found in the\r\n * LICENSE file in the root directory of this source tree. An additional grant\r\n * of patent rights can be found in the PATENTS file in the same directory.\r\n *\r\n * @providesModule getTextContentFromFiles\r\n * @format\r\n * \r\n */\n'use strict';\n\nvar invariant = require('fbjs/lib/invariant');\n\nvar TEXT_CLIPPING_REGEX = /\\.textClipping$/;\nvar TEXT_TYPES = {\n  'text/plain': true,\n  'text/html': true,\n  'text/rtf': true\n}; // Somewhat arbitrary upper bound on text size. Let's not lock up the browser.\n\nvar TEXT_SIZE_UPPER_BOUND = 5000;\n/**\r\n * Extract the text content from a file list.\r\n */\n\nfunction getTextContentFromFiles(files, callback) {\n  var readCount = 0;\n  var results = [];\n  files.forEach(function (\n  /*blob*/\n  file) {\n    readFile(file, function (\n    /*string*/\n    text) {\n      readCount++;\n      text && results.push(text.slice(0, TEXT_SIZE_UPPER_BOUND));\n\n      if (readCount == files.length) {\n        callback(results.join('\\r'));\n      }\n    });\n  });\n}\n/**\r\n * todo isaac: Do work to turn html/rtf into a content fragment.\r\n */\n\n\nfunction readFile(file, callback) {\n  if (!global.FileReader || file.type && !(file.type in TEXT_TYPES)) {\n    callback('');\n    return;\n  }\n\n  if (file.type === '') {\n    var contents = ''; // Special-case text clippings, which have an empty type but include\n    // `.textClipping` in the file name. `readAsText` results in an empty\n    // string for text clippings, so we force the file name to serve\n    // as the text value for the file.\n\n    if (TEXT_CLIPPING_REGEX.test(file.name)) {\n      contents = file.name.replace(TEXT_CLIPPING_REGEX, '');\n    }\n\n    callback(contents);\n    return;\n  }\n\n  var reader = new FileReader();\n\n  reader.onload = function () {\n    var result = reader.result;\n    !(typeof result === 'string') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'We should be calling \"FileReader.readAsText\" which returns a string') : invariant(false) : void 0;\n    callback(result);\n  };\n\n  reader.onerror = function () {\n    callback('');\n  };\n\n  reader.readAsText(file);\n}\n\nmodule.exports = getTextContentFromFiles;","map":{"version":3,"sources":["C:/Users/lepan/Desktop/CIS550-Project/final project/client/node_modules/draft-js/lib/getTextContentFromFiles.js"],"names":["invariant","require","TEXT_CLIPPING_REGEX","TEXT_TYPES","TEXT_SIZE_UPPER_BOUND","getTextContentFromFiles","files","callback","readCount","results","forEach","file","readFile","text","push","slice","length","join","global","FileReader","type","contents","test","name","replace","reader","onload","result","process","env","NODE_ENV","onerror","readAsText","module","exports"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA,IAAIA,SAAS,GAAGC,OAAO,CAAC,oBAAD,CAAvB;;AAEA,IAAIC,mBAAmB,GAAG,iBAA1B;AAEA,IAAIC,UAAU,GAAG;AACf,gBAAc,IADC;AAEf,eAAa,IAFE;AAGf,cAAY;AAHG,CAAjB,C,CAMA;;AACA,IAAIC,qBAAqB,GAAG,IAA5B;AAEA;AACA;AACA;;AACA,SAASC,uBAAT,CAAiCC,KAAjC,EAAwCC,QAAxC,EAAkD;AAChD,MAAIC,SAAS,GAAG,CAAhB;AACA,MAAIC,OAAO,GAAG,EAAd;AACAH,EAAAA,KAAK,CAACI,OAAN,CAAc;AAAW;AAAQC,EAAAA,IAAnB,EAAyB;AACrCC,IAAAA,QAAQ,CAACD,IAAD,EAAO;AAAW;AAAUE,IAAAA,IAArB,EAA2B;AACxCL,MAAAA,SAAS;AACTK,MAAAA,IAAI,IAAIJ,OAAO,CAACK,IAAR,CAAaD,IAAI,CAACE,KAAL,CAAW,CAAX,EAAcX,qBAAd,CAAb,CAAR;;AACA,UAAII,SAAS,IAAIF,KAAK,CAACU,MAAvB,EAA+B;AAC7BT,QAAAA,QAAQ,CAACE,OAAO,CAACQ,IAAR,CAAa,IAAb,CAAD,CAAR;AACD;AACF,KANO,CAAR;AAOD,GARD;AASD;AAED;AACA;AACA;;;AACA,SAASL,QAAT,CAAkBD,IAAlB,EAAwBJ,QAAxB,EAAkC;AAChC,MAAI,CAACW,MAAM,CAACC,UAAR,IAAsBR,IAAI,CAACS,IAAL,IAAa,EAAET,IAAI,CAACS,IAAL,IAAajB,UAAf,CAAvC,EAAmE;AACjEI,IAAAA,QAAQ,CAAC,EAAD,CAAR;AACA;AACD;;AAED,MAAII,IAAI,CAACS,IAAL,KAAc,EAAlB,EAAsB;AACpB,QAAIC,QAAQ,GAAG,EAAf,CADoB,CAEpB;AACA;AACA;AACA;;AACA,QAAInB,mBAAmB,CAACoB,IAApB,CAAyBX,IAAI,CAACY,IAA9B,CAAJ,EAAyC;AACvCF,MAAAA,QAAQ,GAAGV,IAAI,CAACY,IAAL,CAAUC,OAAV,CAAkBtB,mBAAlB,EAAuC,EAAvC,CAAX;AACD;;AACDK,IAAAA,QAAQ,CAACc,QAAD,CAAR;AACA;AACD;;AAED,MAAII,MAAM,GAAG,IAAIN,UAAJ,EAAb;;AACAM,EAAAA,MAAM,CAACC,MAAP,GAAgB,YAAY;AAC1B,QAAIC,MAAM,GAAGF,MAAM,CAACE,MAApB;AACA,MAAE,OAAOA,MAAP,KAAkB,QAApB,IAAgCC,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAAzB,GAAwC9B,SAAS,CAAC,KAAD,EAAQ,qEAAR,CAAjD,GAAkIA,SAAS,CAAC,KAAD,CAA3K,GAAqL,KAAK,CAA1L;AACAO,IAAAA,QAAQ,CAACoB,MAAD,CAAR;AACD,GAJD;;AAKAF,EAAAA,MAAM,CAACM,OAAP,GAAiB,YAAY;AAC3BxB,IAAAA,QAAQ,CAAC,EAAD,CAAR;AACD,GAFD;;AAGAkB,EAAAA,MAAM,CAACO,UAAP,CAAkBrB,IAAlB;AACD;;AAEDsB,MAAM,CAACC,OAAP,GAAiB7B,uBAAjB","sourcesContent":["/**\r\n * Copyright (c) 2013-present, Facebook, Inc.\r\n * All rights reserved.\r\n *\r\n * This source code is licensed under the BSD-style license found in the\r\n * LICENSE file in the root directory of this source tree. An additional grant\r\n * of patent rights can be found in the PATENTS file in the same directory.\r\n *\r\n * @providesModule getTextContentFromFiles\r\n * @format\r\n * \r\n */\r\n\r\n'use strict';\r\n\r\nvar invariant = require('fbjs/lib/invariant');\r\n\r\nvar TEXT_CLIPPING_REGEX = /\\.textClipping$/;\r\n\r\nvar TEXT_TYPES = {\r\n  'text/plain': true,\r\n  'text/html': true,\r\n  'text/rtf': true\r\n};\r\n\r\n// Somewhat arbitrary upper bound on text size. Let's not lock up the browser.\r\nvar TEXT_SIZE_UPPER_BOUND = 5000;\r\n\r\n/**\r\n * Extract the text content from a file list.\r\n */\r\nfunction getTextContentFromFiles(files, callback) {\r\n  var readCount = 0;\r\n  var results = [];\r\n  files.forEach(function ( /*blob*/file) {\r\n    readFile(file, function ( /*string*/text) {\r\n      readCount++;\r\n      text && results.push(text.slice(0, TEXT_SIZE_UPPER_BOUND));\r\n      if (readCount == files.length) {\r\n        callback(results.join('\\r'));\r\n      }\r\n    });\r\n  });\r\n}\r\n\r\n/**\r\n * todo isaac: Do work to turn html/rtf into a content fragment.\r\n */\r\nfunction readFile(file, callback) {\r\n  if (!global.FileReader || file.type && !(file.type in TEXT_TYPES)) {\r\n    callback('');\r\n    return;\r\n  }\r\n\r\n  if (file.type === '') {\r\n    var contents = '';\r\n    // Special-case text clippings, which have an empty type but include\r\n    // `.textClipping` in the file name. `readAsText` results in an empty\r\n    // string for text clippings, so we force the file name to serve\r\n    // as the text value for the file.\r\n    if (TEXT_CLIPPING_REGEX.test(file.name)) {\r\n      contents = file.name.replace(TEXT_CLIPPING_REGEX, '');\r\n    }\r\n    callback(contents);\r\n    return;\r\n  }\r\n\r\n  var reader = new FileReader();\r\n  reader.onload = function () {\r\n    var result = reader.result;\r\n    !(typeof result === 'string') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'We should be calling \"FileReader.readAsText\" which returns a string') : invariant(false) : void 0;\r\n    callback(result);\r\n  };\r\n  reader.onerror = function () {\r\n    callback('');\r\n  };\r\n  reader.readAsText(file);\r\n}\r\n\r\nmodule.exports = getTextContentFromFiles;"]},"metadata":{},"sourceType":"script"}