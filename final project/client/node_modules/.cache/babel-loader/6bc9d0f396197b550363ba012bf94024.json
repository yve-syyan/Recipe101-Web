{"ast":null,"code":"/**\r\n * Copyright (c) 2013-present, Facebook, Inc.\r\n * All rights reserved.\r\n *\r\n * This source code is licensed under the BSD-style license found in the\r\n * LICENSE file in the root directory of this source tree. An additional grant\r\n * of patent rights can be found in the PATENTS file in the same directory.\r\n *\r\n * @providesModule DraftEditorCompositionHandler\r\n * @format\r\n * \r\n */\n'use strict';\n\nvar DraftFeatureFlags = require('./DraftFeatureFlags');\n\nvar DraftModifier = require('./DraftModifier');\n\nvar EditorState = require('./EditorState');\n\nvar Keys = require('fbjs/lib/Keys');\n\nvar getEntityKeyForSelection = require('./getEntityKeyForSelection');\n\nvar isEventHandled = require('./isEventHandled');\n\nvar isSelectionAtLeafStart = require('./isSelectionAtLeafStart');\n/**\r\n * Millisecond delay to allow `compositionstart` to fire again upon\r\n * `compositionend`.\r\n *\r\n * This is used for Korean input to ensure that typing can continue without\r\n * the editor trying to render too quickly. More specifically, Safari 7.1+\r\n * triggers `compositionstart` a little slower than Chrome/FF, which\r\n * leads to composed characters being resolved and re-render occurring\r\n * sooner than we want.\r\n */\n\n\nvar RESOLVE_DELAY = 20;\n/**\r\n * A handful of variables used to track the current composition and its\r\n * resolution status. These exist at the module level because it is not\r\n * possible to have compositions occurring in multiple editors simultaneously,\r\n * and it simplifies state management with respect to the DraftEditor component.\r\n */\n\nvar resolved = false;\nvar stillComposing = false;\nvar textInputData = '';\nvar DraftEditorCompositionHandler = {\n  onBeforeInput: function onBeforeInput(editor, e) {\n    textInputData = (textInputData || '') + e.data;\n  },\n\n  /**\r\n   * A `compositionstart` event has fired while we're still in composition\r\n   * mode. Continue the current composition session to prevent a re-render.\r\n   */\n  onCompositionStart: function onCompositionStart(editor) {\n    stillComposing = true;\n  },\n\n  /**\r\n   * Attempt to end the current composition session.\r\n   *\r\n   * Defer handling because browser will still insert the chars into active\r\n   * element after `compositionend`. If a `compositionstart` event fires\r\n   * before `resolveComposition` executes, our composition session will\r\n   * continue.\r\n   *\r\n   * The `resolved` flag is useful because certain IME interfaces fire the\r\n   * `compositionend` event multiple times, thus queueing up multiple attempts\r\n   * at handling the composition. Since handling the same composition event\r\n   * twice could break the DOM, we only use the first event. Example: Arabic\r\n   * Google Input Tools on Windows 8.1 fires `compositionend` three times.\r\n   */\n  onCompositionEnd: function onCompositionEnd(editor) {\n    resolved = false;\n    stillComposing = false;\n    setTimeout(function () {\n      if (!resolved) {\n        DraftEditorCompositionHandler.resolveComposition(editor);\n      }\n    }, RESOLVE_DELAY);\n  },\n\n  /**\r\n   * In Safari, keydown events may fire when committing compositions. If\r\n   * the arrow keys are used to commit, prevent default so that the cursor\r\n   * doesn't move, otherwise it will jump back noticeably on re-render.\r\n   */\n  onKeyDown: function onKeyDown(editor, e) {\n    if (!stillComposing) {\n      // If a keydown event is received after compositionend but before the\n      // 20ms timer expires (ex: type option-E then backspace, or type A then\n      // backspace in 2-Set Korean), we should immediately resolve the\n      // composition and reinterpret the key press in edit mode.\n      DraftEditorCompositionHandler.resolveComposition(editor);\n\n      editor._onKeyDown(e);\n\n      return;\n    }\n\n    if (e.which === Keys.RIGHT || e.which === Keys.LEFT) {\n      e.preventDefault();\n    }\n  },\n\n  /**\r\n   * Keypress events may fire when committing compositions. In Firefox,\r\n   * pressing RETURN commits the composition and inserts extra newline\r\n   * characters that we do not want. `preventDefault` allows the composition\r\n   * to be committed while preventing the extra characters.\r\n   */\n  onKeyPress: function onKeyPress(editor, e) {\n    if (e.which === Keys.RETURN) {\n      e.preventDefault();\n    }\n  },\n\n  /**\r\n   * Attempt to insert composed characters into the document.\r\n   *\r\n   * If we are still in a composition session, do nothing. Otherwise, insert\r\n   * the characters into the document and terminate the composition session.\r\n   *\r\n   * If no characters were composed -- for instance, the user\r\n   * deleted all composed characters and committed nothing new --\r\n   * force a re-render. We also re-render when the composition occurs\r\n   * at the beginning of a leaf, to ensure that if the browser has\r\n   * created a new text node for the composition, we will discard it.\r\n   *\r\n   * Resetting innerHTML will move focus to the beginning of the editor,\r\n   * so we update to force it back to the correct place.\r\n   */\n  resolveComposition: function resolveComposition(editor) {\n    if (stillComposing) {\n      return;\n    }\n\n    resolved = true;\n    var composedChars = textInputData;\n    textInputData = '';\n    var editorState = EditorState.set(editor._latestEditorState, {\n      inCompositionMode: false\n    });\n    var currentStyle = editorState.getCurrentInlineStyle();\n    var entityKey = getEntityKeyForSelection(editorState.getCurrentContent(), editorState.getSelection());\n    var mustReset = !composedChars || isSelectionAtLeafStart(editorState) || currentStyle.size > 0 || entityKey !== null;\n\n    if (mustReset) {\n      editor.restoreEditorDOM();\n    }\n\n    editor.exitCurrentMode();\n\n    if (composedChars) {\n      if (DraftFeatureFlags.draft_handlebeforeinput_composed_text && editor.props.handleBeforeInput && isEventHandled(editor.props.handleBeforeInput(composedChars, editorState))) {\n        return;\n      } // If characters have been composed, re-rendering with the update\n      // is sufficient to reset the editor.\n\n\n      var contentState = DraftModifier.replaceText(editorState.getCurrentContent(), editorState.getSelection(), composedChars, currentStyle, entityKey);\n      editor.update(EditorState.push(editorState, contentState, 'insert-characters'));\n      return;\n    }\n\n    if (mustReset) {\n      editor.update(EditorState.set(editorState, {\n        nativelyRenderedContent: null,\n        forceSelection: true\n      }));\n    }\n  }\n};\nmodule.exports = DraftEditorCompositionHandler;","map":{"version":3,"sources":["C:/Users/lepan/Desktop/CIS550-Project/final project/client/node_modules/draft-js/lib/DraftEditorCompositionHandler.js"],"names":["DraftFeatureFlags","require","DraftModifier","EditorState","Keys","getEntityKeyForSelection","isEventHandled","isSelectionAtLeafStart","RESOLVE_DELAY","resolved","stillComposing","textInputData","DraftEditorCompositionHandler","onBeforeInput","editor","e","data","onCompositionStart","onCompositionEnd","setTimeout","resolveComposition","onKeyDown","_onKeyDown","which","RIGHT","LEFT","preventDefault","onKeyPress","RETURN","composedChars","editorState","set","_latestEditorState","inCompositionMode","currentStyle","getCurrentInlineStyle","entityKey","getCurrentContent","getSelection","mustReset","size","restoreEditorDOM","exitCurrentMode","draft_handlebeforeinput_composed_text","props","handleBeforeInput","contentState","replaceText","update","push","nativelyRenderedContent","forceSelection","module","exports"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA,IAAIA,iBAAiB,GAAGC,OAAO,CAAC,qBAAD,CAA/B;;AACA,IAAIC,aAAa,GAAGD,OAAO,CAAC,iBAAD,CAA3B;;AACA,IAAIE,WAAW,GAAGF,OAAO,CAAC,eAAD,CAAzB;;AACA,IAAIG,IAAI,GAAGH,OAAO,CAAC,eAAD,CAAlB;;AAEA,IAAII,wBAAwB,GAAGJ,OAAO,CAAC,4BAAD,CAAtC;;AACA,IAAIK,cAAc,GAAGL,OAAO,CAAC,kBAAD,CAA5B;;AACA,IAAIM,sBAAsB,GAAGN,OAAO,CAAC,0BAAD,CAApC;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,IAAIO,aAAa,GAAG,EAApB;AAEA;AACA;AACA;AACA;AACA;AACA;;AACA,IAAIC,QAAQ,GAAG,KAAf;AACA,IAAIC,cAAc,GAAG,KAArB;AACA,IAAIC,aAAa,GAAG,EAApB;AAEA,IAAIC,6BAA6B,GAAG;AAClCC,EAAAA,aAAa,EAAE,SAASA,aAAT,CAAuBC,MAAvB,EAA+BC,CAA/B,EAAkC;AAC/CJ,IAAAA,aAAa,GAAG,CAACA,aAAa,IAAI,EAAlB,IAAwBI,CAAC,CAACC,IAA1C;AACD,GAHiC;;AAKlC;AACF;AACA;AACA;AACEC,EAAAA,kBAAkB,EAAE,SAASA,kBAAT,CAA4BH,MAA5B,EAAoC;AACtDJ,IAAAA,cAAc,GAAG,IAAjB;AACD,GAXiC;;AAalC;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACEQ,EAAAA,gBAAgB,EAAE,SAASA,gBAAT,CAA0BJ,MAA1B,EAAkC;AAClDL,IAAAA,QAAQ,GAAG,KAAX;AACAC,IAAAA,cAAc,GAAG,KAAjB;AACAS,IAAAA,UAAU,CAAC,YAAY;AACrB,UAAI,CAACV,QAAL,EAAe;AACbG,QAAAA,6BAA6B,CAACQ,kBAA9B,CAAiDN,MAAjD;AACD;AACF,KAJS,EAIPN,aAJO,CAAV;AAKD,GAnCiC;;AAqClC;AACF;AACA;AACA;AACA;AACEa,EAAAA,SAAS,EAAE,SAASA,SAAT,CAAmBP,MAAnB,EAA2BC,CAA3B,EAA8B;AACvC,QAAI,CAACL,cAAL,EAAqB;AACnB;AACA;AACA;AACA;AACAE,MAAAA,6BAA6B,CAACQ,kBAA9B,CAAiDN,MAAjD;;AACAA,MAAAA,MAAM,CAACQ,UAAP,CAAkBP,CAAlB;;AACA;AACD;;AACD,QAAIA,CAAC,CAACQ,KAAF,KAAYnB,IAAI,CAACoB,KAAjB,IAA0BT,CAAC,CAACQ,KAAF,KAAYnB,IAAI,CAACqB,IAA/C,EAAqD;AACnDV,MAAAA,CAAC,CAACW,cAAF;AACD;AACF,GAvDiC;;AAyDlC;AACF;AACA;AACA;AACA;AACA;AACEC,EAAAA,UAAU,EAAE,SAASA,UAAT,CAAoBb,MAApB,EAA4BC,CAA5B,EAA+B;AACzC,QAAIA,CAAC,CAACQ,KAAF,KAAYnB,IAAI,CAACwB,MAArB,EAA6B;AAC3Bb,MAAAA,CAAC,CAACW,cAAF;AACD;AACF,GAnEiC;;AAqElC;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACEN,EAAAA,kBAAkB,EAAE,SAASA,kBAAT,CAA4BN,MAA5B,EAAoC;AACtD,QAAIJ,cAAJ,EAAoB;AAClB;AACD;;AAEDD,IAAAA,QAAQ,GAAG,IAAX;AACA,QAAIoB,aAAa,GAAGlB,aAApB;AACAA,IAAAA,aAAa,GAAG,EAAhB;AAEA,QAAImB,WAAW,GAAG3B,WAAW,CAAC4B,GAAZ,CAAgBjB,MAAM,CAACkB,kBAAvB,EAA2C;AAC3DC,MAAAA,iBAAiB,EAAE;AADwC,KAA3C,CAAlB;AAIA,QAAIC,YAAY,GAAGJ,WAAW,CAACK,qBAAZ,EAAnB;AACA,QAAIC,SAAS,GAAG/B,wBAAwB,CAACyB,WAAW,CAACO,iBAAZ,EAAD,EAAkCP,WAAW,CAACQ,YAAZ,EAAlC,CAAxC;AAEA,QAAIC,SAAS,GAAG,CAACV,aAAD,IAAkBtB,sBAAsB,CAACuB,WAAD,CAAxC,IAAyDI,YAAY,CAACM,IAAb,GAAoB,CAA7E,IAAkFJ,SAAS,KAAK,IAAhH;;AAEA,QAAIG,SAAJ,EAAe;AACbzB,MAAAA,MAAM,CAAC2B,gBAAP;AACD;;AAED3B,IAAAA,MAAM,CAAC4B,eAAP;;AAEA,QAAIb,aAAJ,EAAmB;AACjB,UAAI7B,iBAAiB,CAAC2C,qCAAlB,IAA2D7B,MAAM,CAAC8B,KAAP,CAAaC,iBAAxE,IAA6FvC,cAAc,CAACQ,MAAM,CAAC8B,KAAP,CAAaC,iBAAb,CAA+BhB,aAA/B,EAA8CC,WAA9C,CAAD,CAA/G,EAA6K;AAC3K;AACD,OAHgB,CAIjB;AACA;;;AACA,UAAIgB,YAAY,GAAG5C,aAAa,CAAC6C,WAAd,CAA0BjB,WAAW,CAACO,iBAAZ,EAA1B,EAA2DP,WAAW,CAACQ,YAAZ,EAA3D,EAAuFT,aAAvF,EAAsGK,YAAtG,EAAoHE,SAApH,CAAnB;AACAtB,MAAAA,MAAM,CAACkC,MAAP,CAAc7C,WAAW,CAAC8C,IAAZ,CAAiBnB,WAAjB,EAA8BgB,YAA9B,EAA4C,mBAA5C,CAAd;AACA;AACD;;AAED,QAAIP,SAAJ,EAAe;AACbzB,MAAAA,MAAM,CAACkC,MAAP,CAAc7C,WAAW,CAAC4B,GAAZ,CAAgBD,WAAhB,EAA6B;AACzCoB,QAAAA,uBAAuB,EAAE,IADgB;AAEzCC,QAAAA,cAAc,EAAE;AAFyB,OAA7B,CAAd;AAID;AACF;AA7HiC,CAApC;AAgIAC,MAAM,CAACC,OAAP,GAAiBzC,6BAAjB","sourcesContent":["/**\r\n * Copyright (c) 2013-present, Facebook, Inc.\r\n * All rights reserved.\r\n *\r\n * This source code is licensed under the BSD-style license found in the\r\n * LICENSE file in the root directory of this source tree. An additional grant\r\n * of patent rights can be found in the PATENTS file in the same directory.\r\n *\r\n * @providesModule DraftEditorCompositionHandler\r\n * @format\r\n * \r\n */\r\n\r\n'use strict';\r\n\r\nvar DraftFeatureFlags = require('./DraftFeatureFlags');\r\nvar DraftModifier = require('./DraftModifier');\r\nvar EditorState = require('./EditorState');\r\nvar Keys = require('fbjs/lib/Keys');\r\n\r\nvar getEntityKeyForSelection = require('./getEntityKeyForSelection');\r\nvar isEventHandled = require('./isEventHandled');\r\nvar isSelectionAtLeafStart = require('./isSelectionAtLeafStart');\r\n\r\n/**\r\n * Millisecond delay to allow `compositionstart` to fire again upon\r\n * `compositionend`.\r\n *\r\n * This is used for Korean input to ensure that typing can continue without\r\n * the editor trying to render too quickly. More specifically, Safari 7.1+\r\n * triggers `compositionstart` a little slower than Chrome/FF, which\r\n * leads to composed characters being resolved and re-render occurring\r\n * sooner than we want.\r\n */\r\nvar RESOLVE_DELAY = 20;\r\n\r\n/**\r\n * A handful of variables used to track the current composition and its\r\n * resolution status. These exist at the module level because it is not\r\n * possible to have compositions occurring in multiple editors simultaneously,\r\n * and it simplifies state management with respect to the DraftEditor component.\r\n */\r\nvar resolved = false;\r\nvar stillComposing = false;\r\nvar textInputData = '';\r\n\r\nvar DraftEditorCompositionHandler = {\r\n  onBeforeInput: function onBeforeInput(editor, e) {\r\n    textInputData = (textInputData || '') + e.data;\r\n  },\r\n\r\n  /**\r\n   * A `compositionstart` event has fired while we're still in composition\r\n   * mode. Continue the current composition session to prevent a re-render.\r\n   */\r\n  onCompositionStart: function onCompositionStart(editor) {\r\n    stillComposing = true;\r\n  },\r\n\r\n  /**\r\n   * Attempt to end the current composition session.\r\n   *\r\n   * Defer handling because browser will still insert the chars into active\r\n   * element after `compositionend`. If a `compositionstart` event fires\r\n   * before `resolveComposition` executes, our composition session will\r\n   * continue.\r\n   *\r\n   * The `resolved` flag is useful because certain IME interfaces fire the\r\n   * `compositionend` event multiple times, thus queueing up multiple attempts\r\n   * at handling the composition. Since handling the same composition event\r\n   * twice could break the DOM, we only use the first event. Example: Arabic\r\n   * Google Input Tools on Windows 8.1 fires `compositionend` three times.\r\n   */\r\n  onCompositionEnd: function onCompositionEnd(editor) {\r\n    resolved = false;\r\n    stillComposing = false;\r\n    setTimeout(function () {\r\n      if (!resolved) {\r\n        DraftEditorCompositionHandler.resolveComposition(editor);\r\n      }\r\n    }, RESOLVE_DELAY);\r\n  },\r\n\r\n  /**\r\n   * In Safari, keydown events may fire when committing compositions. If\r\n   * the arrow keys are used to commit, prevent default so that the cursor\r\n   * doesn't move, otherwise it will jump back noticeably on re-render.\r\n   */\r\n  onKeyDown: function onKeyDown(editor, e) {\r\n    if (!stillComposing) {\r\n      // If a keydown event is received after compositionend but before the\r\n      // 20ms timer expires (ex: type option-E then backspace, or type A then\r\n      // backspace in 2-Set Korean), we should immediately resolve the\r\n      // composition and reinterpret the key press in edit mode.\r\n      DraftEditorCompositionHandler.resolveComposition(editor);\r\n      editor._onKeyDown(e);\r\n      return;\r\n    }\r\n    if (e.which === Keys.RIGHT || e.which === Keys.LEFT) {\r\n      e.preventDefault();\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Keypress events may fire when committing compositions. In Firefox,\r\n   * pressing RETURN commits the composition and inserts extra newline\r\n   * characters that we do not want. `preventDefault` allows the composition\r\n   * to be committed while preventing the extra characters.\r\n   */\r\n  onKeyPress: function onKeyPress(editor, e) {\r\n    if (e.which === Keys.RETURN) {\r\n      e.preventDefault();\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Attempt to insert composed characters into the document.\r\n   *\r\n   * If we are still in a composition session, do nothing. Otherwise, insert\r\n   * the characters into the document and terminate the composition session.\r\n   *\r\n   * If no characters were composed -- for instance, the user\r\n   * deleted all composed characters and committed nothing new --\r\n   * force a re-render. We also re-render when the composition occurs\r\n   * at the beginning of a leaf, to ensure that if the browser has\r\n   * created a new text node for the composition, we will discard it.\r\n   *\r\n   * Resetting innerHTML will move focus to the beginning of the editor,\r\n   * so we update to force it back to the correct place.\r\n   */\r\n  resolveComposition: function resolveComposition(editor) {\r\n    if (stillComposing) {\r\n      return;\r\n    }\r\n\r\n    resolved = true;\r\n    var composedChars = textInputData;\r\n    textInputData = '';\r\n\r\n    var editorState = EditorState.set(editor._latestEditorState, {\r\n      inCompositionMode: false\r\n    });\r\n\r\n    var currentStyle = editorState.getCurrentInlineStyle();\r\n    var entityKey = getEntityKeyForSelection(editorState.getCurrentContent(), editorState.getSelection());\r\n\r\n    var mustReset = !composedChars || isSelectionAtLeafStart(editorState) || currentStyle.size > 0 || entityKey !== null;\r\n\r\n    if (mustReset) {\r\n      editor.restoreEditorDOM();\r\n    }\r\n\r\n    editor.exitCurrentMode();\r\n\r\n    if (composedChars) {\r\n      if (DraftFeatureFlags.draft_handlebeforeinput_composed_text && editor.props.handleBeforeInput && isEventHandled(editor.props.handleBeforeInput(composedChars, editorState))) {\r\n        return;\r\n      }\r\n      // If characters have been composed, re-rendering with the update\r\n      // is sufficient to reset the editor.\r\n      var contentState = DraftModifier.replaceText(editorState.getCurrentContent(), editorState.getSelection(), composedChars, currentStyle, entityKey);\r\n      editor.update(EditorState.push(editorState, contentState, 'insert-characters'));\r\n      return;\r\n    }\r\n\r\n    if (mustReset) {\r\n      editor.update(EditorState.set(editorState, {\r\n        nativelyRenderedContent: null,\r\n        forceSelection: true\r\n      }));\r\n    }\r\n  }\r\n};\r\n\r\nmodule.exports = DraftEditorCompositionHandler;"]},"metadata":{},"sourceType":"script"}