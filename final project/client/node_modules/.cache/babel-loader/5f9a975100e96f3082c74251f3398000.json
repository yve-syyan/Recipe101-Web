{"ast":null,"code":"/**\r\n * Copyright (c) 2013-present, Facebook, Inc.\r\n * All rights reserved.\r\n *\r\n * This source code is licensed under the BSD-style license found in the\r\n * LICENSE file in the root directory of this source tree. An additional grant\r\n * of patent rights can be found in the PATENTS file in the same directory.\r\n *\r\n * @providesModule editOnPaste\r\n * @format\r\n * \r\n */\n'use strict';\n\nvar BlockMapBuilder = require('./BlockMapBuilder');\n\nvar CharacterMetadata = require('./CharacterMetadata');\n\nvar DataTransfer = require('fbjs/lib/DataTransfer');\n\nvar DraftModifier = require('./DraftModifier');\n\nvar DraftPasteProcessor = require('./DraftPasteProcessor');\n\nvar EditorState = require('./EditorState');\n\nvar RichTextEditorUtil = require('./RichTextEditorUtil');\n\nvar getEntityKeyForSelection = require('./getEntityKeyForSelection');\n\nvar getTextContentFromFiles = require('./getTextContentFromFiles');\n\nvar isEventHandled = require('./isEventHandled');\n\nvar splitTextIntoTextBlocks = require('./splitTextIntoTextBlocks');\n/**\r\n * Paste content.\r\n */\n\n\nfunction editOnPaste(editor, e) {\n  e.preventDefault();\n  var data = new DataTransfer(e.clipboardData); // Get files, unless this is likely to be a string the user wants inline.\n\n  if (!data.isRichText()) {\n    var files = data.getFiles();\n    var defaultFileText = data.getText();\n\n    if (files.length > 0) {\n      // Allow customized paste handling for images, etc. Otherwise, fall\n      // through to insert text contents into the editor.\n      if (editor.props.handlePastedFiles && isEventHandled(editor.props.handlePastedFiles(files))) {\n        return;\n      }\n\n      getTextContentFromFiles(files, function (\n      /*string*/\n      fileText) {\n        fileText = fileText || defaultFileText;\n\n        if (!fileText) {\n          return;\n        }\n\n        var editorState = editor._latestEditorState;\n        var blocks = splitTextIntoTextBlocks(fileText);\n        var character = CharacterMetadata.create({\n          style: editorState.getCurrentInlineStyle(),\n          entity: getEntityKeyForSelection(editorState.getCurrentContent(), editorState.getSelection())\n        });\n        var currentBlockType = RichTextEditorUtil.getCurrentBlockType(editorState);\n        var text = DraftPasteProcessor.processText(blocks, character, currentBlockType);\n        var fragment = BlockMapBuilder.createFromArray(text);\n        var withInsertedText = DraftModifier.replaceWithFragment(editorState.getCurrentContent(), editorState.getSelection(), fragment);\n        editor.update(EditorState.push(editorState, withInsertedText, 'insert-fragment'));\n      });\n      return;\n    }\n  }\n\n  var textBlocks = [];\n  var text = data.getText();\n  var html = data.getHTML();\n  var editorState = editor._latestEditorState;\n\n  if (editor.props.handlePastedText && isEventHandled(editor.props.handlePastedText(text, html, editorState))) {\n    return;\n  }\n\n  if (text) {\n    textBlocks = splitTextIntoTextBlocks(text);\n  }\n\n  if (!editor.props.stripPastedStyles) {\n    // If the text from the paste event is rich content that matches what we\n    // already have on the internal clipboard, assume that we should just use\n    // the clipboard fragment for the paste. This will allow us to preserve\n    // styling and entities, if any are present. Note that newlines are\n    // stripped during comparison -- this is because copy/paste within the\n    // editor in Firefox and IE will not include empty lines. The resulting\n    // paste will preserve the newlines correctly.\n    var internalClipboard = editor.getClipboard();\n\n    if (data.isRichText() && internalClipboard) {\n      if ( // If the editorKey is present in the pasted HTML, it should be safe to\n      // assume this is an internal paste.\n      html.indexOf(editor.getEditorKey()) !== -1 || // The copy may have been made within a single block, in which case the\n      // editor key won't be part of the paste. In this case, just check\n      // whether the pasted text matches the internal clipboard.\n      textBlocks.length === 1 && internalClipboard.size === 1 && internalClipboard.first().getText() === text) {\n        editor.update(insertFragment(editor._latestEditorState, internalClipboard));\n        return;\n      }\n    } else if (internalClipboard && data.types.includes('com.apple.webarchive') && !data.types.includes('text/html') && areTextBlocksAndClipboardEqual(textBlocks, internalClipboard)) {\n      // Safari does not properly store text/html in some cases.\n      // Use the internalClipboard if present and equal to what is on\n      // the clipboard. See https://bugs.webkit.org/show_bug.cgi?id=19893.\n      editor.update(insertFragment(editor._latestEditorState, internalClipboard));\n      return;\n    } // If there is html paste data, try to parse that.\n\n\n    if (html) {\n      var htmlFragment = DraftPasteProcessor.processHTML(html, editor.props.blockRenderMap);\n\n      if (htmlFragment) {\n        var contentBlocks = htmlFragment.contentBlocks,\n            entityMap = htmlFragment.entityMap;\n\n        if (contentBlocks) {\n          var htmlMap = BlockMapBuilder.createFromArray(contentBlocks);\n          editor.update(insertFragment(editor._latestEditorState, htmlMap, entityMap));\n          return;\n        }\n      }\n    } // Otherwise, create a new fragment from our pasted text. Also\n    // empty the internal clipboard, since it's no longer valid.\n\n\n    editor.setClipboard(null);\n  }\n\n  if (textBlocks.length) {\n    var character = CharacterMetadata.create({\n      style: editorState.getCurrentInlineStyle(),\n      entity: getEntityKeyForSelection(editorState.getCurrentContent(), editorState.getSelection())\n    });\n    var currentBlockType = RichTextEditorUtil.getCurrentBlockType(editorState);\n    var textFragment = DraftPasteProcessor.processText(textBlocks, character, currentBlockType);\n    var textMap = BlockMapBuilder.createFromArray(textFragment);\n    editor.update(insertFragment(editor._latestEditorState, textMap));\n  }\n}\n\nfunction insertFragment(editorState, fragment, entityMap) {\n  var newContent = DraftModifier.replaceWithFragment(editorState.getCurrentContent(), editorState.getSelection(), fragment); // TODO: merge the entity map once we stop using DraftEntity\n  // like this:\n  // const mergedEntityMap = newContent.getEntityMap().merge(entityMap);\n\n  return EditorState.push(editorState, newContent.set('entityMap', entityMap), 'insert-fragment');\n}\n\nfunction areTextBlocksAndClipboardEqual(textBlocks, blockMap) {\n  return textBlocks.length === blockMap.size && blockMap.valueSeq().every(function (block, ii) {\n    return block.getText() === textBlocks[ii];\n  });\n}\n\nmodule.exports = editOnPaste;","map":{"version":3,"sources":["C:/Users/lepan/Desktop/CIS550-Project/final project/client/node_modules/draft-js/lib/editOnPaste.js"],"names":["BlockMapBuilder","require","CharacterMetadata","DataTransfer","DraftModifier","DraftPasteProcessor","EditorState","RichTextEditorUtil","getEntityKeyForSelection","getTextContentFromFiles","isEventHandled","splitTextIntoTextBlocks","editOnPaste","editor","e","preventDefault","data","clipboardData","isRichText","files","getFiles","defaultFileText","getText","length","props","handlePastedFiles","fileText","editorState","_latestEditorState","blocks","character","create","style","getCurrentInlineStyle","entity","getCurrentContent","getSelection","currentBlockType","getCurrentBlockType","text","processText","fragment","createFromArray","withInsertedText","replaceWithFragment","update","push","textBlocks","html","getHTML","handlePastedText","stripPastedStyles","internalClipboard","getClipboard","indexOf","getEditorKey","size","first","insertFragment","types","includes","areTextBlocksAndClipboardEqual","htmlFragment","processHTML","blockRenderMap","contentBlocks","entityMap","htmlMap","setClipboard","textFragment","textMap","newContent","set","blockMap","valueSeq","every","block","ii","module","exports"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA,IAAIA,eAAe,GAAGC,OAAO,CAAC,mBAAD,CAA7B;;AACA,IAAIC,iBAAiB,GAAGD,OAAO,CAAC,qBAAD,CAA/B;;AACA,IAAIE,YAAY,GAAGF,OAAO,CAAC,uBAAD,CAA1B;;AACA,IAAIG,aAAa,GAAGH,OAAO,CAAC,iBAAD,CAA3B;;AACA,IAAII,mBAAmB,GAAGJ,OAAO,CAAC,uBAAD,CAAjC;;AACA,IAAIK,WAAW,GAAGL,OAAO,CAAC,eAAD,CAAzB;;AACA,IAAIM,kBAAkB,GAAGN,OAAO,CAAC,sBAAD,CAAhC;;AAEA,IAAIO,wBAAwB,GAAGP,OAAO,CAAC,4BAAD,CAAtC;;AACA,IAAIQ,uBAAuB,GAAGR,OAAO,CAAC,2BAAD,CAArC;;AACA,IAAIS,cAAc,GAAGT,OAAO,CAAC,kBAAD,CAA5B;;AACA,IAAIU,uBAAuB,GAAGV,OAAO,CAAC,2BAAD,CAArC;AAEA;AACA;AACA;;;AACA,SAASW,WAAT,CAAqBC,MAArB,EAA6BC,CAA7B,EAAgC;AAC9BA,EAAAA,CAAC,CAACC,cAAF;AACA,MAAIC,IAAI,GAAG,IAAIb,YAAJ,CAAiBW,CAAC,CAACG,aAAnB,CAAX,CAF8B,CAI9B;;AACA,MAAI,CAACD,IAAI,CAACE,UAAL,EAAL,EAAwB;AACtB,QAAIC,KAAK,GAAGH,IAAI,CAACI,QAAL,EAAZ;AACA,QAAIC,eAAe,GAAGL,IAAI,CAACM,OAAL,EAAtB;;AACA,QAAIH,KAAK,CAACI,MAAN,GAAe,CAAnB,EAAsB;AACpB;AACA;AACA,UAAIV,MAAM,CAACW,KAAP,CAAaC,iBAAb,IAAkCf,cAAc,CAACG,MAAM,CAACW,KAAP,CAAaC,iBAAb,CAA+BN,KAA/B,CAAD,CAApD,EAA6F;AAC3F;AACD;;AAEDV,MAAAA,uBAAuB,CAACU,KAAD,EAAQ;AAAW;AAAUO,MAAAA,QAArB,EAA+B;AAC5DA,QAAAA,QAAQ,GAAGA,QAAQ,IAAIL,eAAvB;;AACA,YAAI,CAACK,QAAL,EAAe;AACb;AACD;;AAED,YAAIC,WAAW,GAAGd,MAAM,CAACe,kBAAzB;AACA,YAAIC,MAAM,GAAGlB,uBAAuB,CAACe,QAAD,CAApC;AACA,YAAII,SAAS,GAAG5B,iBAAiB,CAAC6B,MAAlB,CAAyB;AACvCC,UAAAA,KAAK,EAAEL,WAAW,CAACM,qBAAZ,EADgC;AAEvCC,UAAAA,MAAM,EAAE1B,wBAAwB,CAACmB,WAAW,CAACQ,iBAAZ,EAAD,EAAkCR,WAAW,CAACS,YAAZ,EAAlC;AAFO,SAAzB,CAAhB;AAIA,YAAIC,gBAAgB,GAAG9B,kBAAkB,CAAC+B,mBAAnB,CAAuCX,WAAvC,CAAvB;AAEA,YAAIY,IAAI,GAAGlC,mBAAmB,CAACmC,WAApB,CAAgCX,MAAhC,EAAwCC,SAAxC,EAAmDO,gBAAnD,CAAX;AACA,YAAII,QAAQ,GAAGzC,eAAe,CAAC0C,eAAhB,CAAgCH,IAAhC,CAAf;AAEA,YAAII,gBAAgB,GAAGvC,aAAa,CAACwC,mBAAd,CAAkCjB,WAAW,CAACQ,iBAAZ,EAAlC,EAAmER,WAAW,CAACS,YAAZ,EAAnE,EAA+FK,QAA/F,CAAvB;AAEA5B,QAAAA,MAAM,CAACgC,MAAP,CAAcvC,WAAW,CAACwC,IAAZ,CAAiBnB,WAAjB,EAA8BgB,gBAA9B,EAAgD,iBAAhD,CAAd;AACD,OApBsB,CAAvB;AAsBA;AACD;AACF;;AAED,MAAII,UAAU,GAAG,EAAjB;AACA,MAAIR,IAAI,GAAGvB,IAAI,CAACM,OAAL,EAAX;AACA,MAAI0B,IAAI,GAAGhC,IAAI,CAACiC,OAAL,EAAX;AACA,MAAItB,WAAW,GAAGd,MAAM,CAACe,kBAAzB;;AAEA,MAAIf,MAAM,CAACW,KAAP,CAAa0B,gBAAb,IAAiCxC,cAAc,CAACG,MAAM,CAACW,KAAP,CAAa0B,gBAAb,CAA8BX,IAA9B,EAAoCS,IAApC,EAA0CrB,WAA1C,CAAD,CAAnD,EAA6G;AAC3G;AACD;;AAED,MAAIY,IAAJ,EAAU;AACRQ,IAAAA,UAAU,GAAGpC,uBAAuB,CAAC4B,IAAD,CAApC;AACD;;AAED,MAAI,CAAC1B,MAAM,CAACW,KAAP,CAAa2B,iBAAlB,EAAqC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAIC,iBAAiB,GAAGvC,MAAM,CAACwC,YAAP,EAAxB;;AACA,QAAIrC,IAAI,CAACE,UAAL,MAAqBkC,iBAAzB,EAA4C;AAC1C,WACA;AACA;AACAJ,MAAAA,IAAI,CAACM,OAAL,CAAazC,MAAM,CAAC0C,YAAP,EAAb,MAAwC,CAAC,CAAzC,IACA;AACA;AACA;AACAR,MAAAA,UAAU,CAACxB,MAAX,KAAsB,CAAtB,IAA2B6B,iBAAiB,CAACI,IAAlB,KAA2B,CAAtD,IAA2DJ,iBAAiB,CAACK,KAAlB,GAA0BnC,OAA1B,OAAwCiB,IAPnG,EAOyG;AACvG1B,QAAAA,MAAM,CAACgC,MAAP,CAAca,cAAc,CAAC7C,MAAM,CAACe,kBAAR,EAA4BwB,iBAA5B,CAA5B;AACA;AACD;AACF,KAZD,MAYO,IAAIA,iBAAiB,IAAIpC,IAAI,CAAC2C,KAAL,CAAWC,QAAX,CAAoB,sBAApB,CAArB,IAAoE,CAAC5C,IAAI,CAAC2C,KAAL,CAAWC,QAAX,CAAoB,WAApB,CAArE,IAAyGC,8BAA8B,CAACd,UAAD,EAAaK,iBAAb,CAA3I,EAA4K;AACjL;AACA;AACA;AACAvC,MAAAA,MAAM,CAACgC,MAAP,CAAca,cAAc,CAAC7C,MAAM,CAACe,kBAAR,EAA4BwB,iBAA5B,CAA5B;AACA;AACD,KA3BkC,CA6BnC;;;AACA,QAAIJ,IAAJ,EAAU;AACR,UAAIc,YAAY,GAAGzD,mBAAmB,CAAC0D,WAApB,CAAgCf,IAAhC,EAAsCnC,MAAM,CAACW,KAAP,CAAawC,cAAnD,CAAnB;;AACA,UAAIF,YAAJ,EAAkB;AAChB,YAAIG,aAAa,GAAGH,YAAY,CAACG,aAAjC;AAAA,YACIC,SAAS,GAAGJ,YAAY,CAACI,SAD7B;;AAGA,YAAID,aAAJ,EAAmB;AACjB,cAAIE,OAAO,GAAGnE,eAAe,CAAC0C,eAAhB,CAAgCuB,aAAhC,CAAd;AACApD,UAAAA,MAAM,CAACgC,MAAP,CAAca,cAAc,CAAC7C,MAAM,CAACe,kBAAR,EAA4BuC,OAA5B,EAAqCD,SAArC,CAA5B;AACA;AACD;AACF;AACF,KA1CkC,CA4CnC;AACA;;;AACArD,IAAAA,MAAM,CAACuD,YAAP,CAAoB,IAApB;AACD;;AAED,MAAIrB,UAAU,CAACxB,MAAf,EAAuB;AACrB,QAAIO,SAAS,GAAG5B,iBAAiB,CAAC6B,MAAlB,CAAyB;AACvCC,MAAAA,KAAK,EAAEL,WAAW,CAACM,qBAAZ,EADgC;AAEvCC,MAAAA,MAAM,EAAE1B,wBAAwB,CAACmB,WAAW,CAACQ,iBAAZ,EAAD,EAAkCR,WAAW,CAACS,YAAZ,EAAlC;AAFO,KAAzB,CAAhB;AAKA,QAAIC,gBAAgB,GAAG9B,kBAAkB,CAAC+B,mBAAnB,CAAuCX,WAAvC,CAAvB;AAEA,QAAI0C,YAAY,GAAGhE,mBAAmB,CAACmC,WAApB,CAAgCO,UAAhC,EAA4CjB,SAA5C,EAAuDO,gBAAvD,CAAnB;AAEA,QAAIiC,OAAO,GAAGtE,eAAe,CAAC0C,eAAhB,CAAgC2B,YAAhC,CAAd;AACAxD,IAAAA,MAAM,CAACgC,MAAP,CAAca,cAAc,CAAC7C,MAAM,CAACe,kBAAR,EAA4B0C,OAA5B,CAA5B;AACD;AACF;;AAED,SAASZ,cAAT,CAAwB/B,WAAxB,EAAqCc,QAArC,EAA+CyB,SAA/C,EAA0D;AACxD,MAAIK,UAAU,GAAGnE,aAAa,CAACwC,mBAAd,CAAkCjB,WAAW,CAACQ,iBAAZ,EAAlC,EAAmER,WAAW,CAACS,YAAZ,EAAnE,EAA+FK,QAA/F,CAAjB,CADwD,CAExD;AACA;AACA;;AAEA,SAAOnC,WAAW,CAACwC,IAAZ,CAAiBnB,WAAjB,EAA8B4C,UAAU,CAACC,GAAX,CAAe,WAAf,EAA4BN,SAA5B,CAA9B,EAAsE,iBAAtE,CAAP;AACD;;AAED,SAASL,8BAAT,CAAwCd,UAAxC,EAAoD0B,QAApD,EAA8D;AAC5D,SAAO1B,UAAU,CAACxB,MAAX,KAAsBkD,QAAQ,CAACjB,IAA/B,IAAuCiB,QAAQ,CAACC,QAAT,GAAoBC,KAApB,CAA0B,UAAUC,KAAV,EAAiBC,EAAjB,EAAqB;AAC3F,WAAOD,KAAK,CAACtD,OAAN,OAAoByB,UAAU,CAAC8B,EAAD,CAArC;AACD,GAF6C,CAA9C;AAGD;;AAEDC,MAAM,CAACC,OAAP,GAAiBnE,WAAjB","sourcesContent":["/**\r\n * Copyright (c) 2013-present, Facebook, Inc.\r\n * All rights reserved.\r\n *\r\n * This source code is licensed under the BSD-style license found in the\r\n * LICENSE file in the root directory of this source tree. An additional grant\r\n * of patent rights can be found in the PATENTS file in the same directory.\r\n *\r\n * @providesModule editOnPaste\r\n * @format\r\n * \r\n */\r\n\r\n'use strict';\r\n\r\nvar BlockMapBuilder = require('./BlockMapBuilder');\r\nvar CharacterMetadata = require('./CharacterMetadata');\r\nvar DataTransfer = require('fbjs/lib/DataTransfer');\r\nvar DraftModifier = require('./DraftModifier');\r\nvar DraftPasteProcessor = require('./DraftPasteProcessor');\r\nvar EditorState = require('./EditorState');\r\nvar RichTextEditorUtil = require('./RichTextEditorUtil');\r\n\r\nvar getEntityKeyForSelection = require('./getEntityKeyForSelection');\r\nvar getTextContentFromFiles = require('./getTextContentFromFiles');\r\nvar isEventHandled = require('./isEventHandled');\r\nvar splitTextIntoTextBlocks = require('./splitTextIntoTextBlocks');\r\n\r\n/**\r\n * Paste content.\r\n */\r\nfunction editOnPaste(editor, e) {\r\n  e.preventDefault();\r\n  var data = new DataTransfer(e.clipboardData);\r\n\r\n  // Get files, unless this is likely to be a string the user wants inline.\r\n  if (!data.isRichText()) {\r\n    var files = data.getFiles();\r\n    var defaultFileText = data.getText();\r\n    if (files.length > 0) {\r\n      // Allow customized paste handling for images, etc. Otherwise, fall\r\n      // through to insert text contents into the editor.\r\n      if (editor.props.handlePastedFiles && isEventHandled(editor.props.handlePastedFiles(files))) {\r\n        return;\r\n      }\r\n\r\n      getTextContentFromFiles(files, function ( /*string*/fileText) {\r\n        fileText = fileText || defaultFileText;\r\n        if (!fileText) {\r\n          return;\r\n        }\r\n\r\n        var editorState = editor._latestEditorState;\r\n        var blocks = splitTextIntoTextBlocks(fileText);\r\n        var character = CharacterMetadata.create({\r\n          style: editorState.getCurrentInlineStyle(),\r\n          entity: getEntityKeyForSelection(editorState.getCurrentContent(), editorState.getSelection())\r\n        });\r\n        var currentBlockType = RichTextEditorUtil.getCurrentBlockType(editorState);\r\n\r\n        var text = DraftPasteProcessor.processText(blocks, character, currentBlockType);\r\n        var fragment = BlockMapBuilder.createFromArray(text);\r\n\r\n        var withInsertedText = DraftModifier.replaceWithFragment(editorState.getCurrentContent(), editorState.getSelection(), fragment);\r\n\r\n        editor.update(EditorState.push(editorState, withInsertedText, 'insert-fragment'));\r\n      });\r\n\r\n      return;\r\n    }\r\n  }\r\n\r\n  var textBlocks = [];\r\n  var text = data.getText();\r\n  var html = data.getHTML();\r\n  var editorState = editor._latestEditorState;\r\n\r\n  if (editor.props.handlePastedText && isEventHandled(editor.props.handlePastedText(text, html, editorState))) {\r\n    return;\r\n  }\r\n\r\n  if (text) {\r\n    textBlocks = splitTextIntoTextBlocks(text);\r\n  }\r\n\r\n  if (!editor.props.stripPastedStyles) {\r\n    // If the text from the paste event is rich content that matches what we\r\n    // already have on the internal clipboard, assume that we should just use\r\n    // the clipboard fragment for the paste. This will allow us to preserve\r\n    // styling and entities, if any are present. Note that newlines are\r\n    // stripped during comparison -- this is because copy/paste within the\r\n    // editor in Firefox and IE will not include empty lines. The resulting\r\n    // paste will preserve the newlines correctly.\r\n    var internalClipboard = editor.getClipboard();\r\n    if (data.isRichText() && internalClipboard) {\r\n      if (\r\n      // If the editorKey is present in the pasted HTML, it should be safe to\r\n      // assume this is an internal paste.\r\n      html.indexOf(editor.getEditorKey()) !== -1 ||\r\n      // The copy may have been made within a single block, in which case the\r\n      // editor key won't be part of the paste. In this case, just check\r\n      // whether the pasted text matches the internal clipboard.\r\n      textBlocks.length === 1 && internalClipboard.size === 1 && internalClipboard.first().getText() === text) {\r\n        editor.update(insertFragment(editor._latestEditorState, internalClipboard));\r\n        return;\r\n      }\r\n    } else if (internalClipboard && data.types.includes('com.apple.webarchive') && !data.types.includes('text/html') && areTextBlocksAndClipboardEqual(textBlocks, internalClipboard)) {\r\n      // Safari does not properly store text/html in some cases.\r\n      // Use the internalClipboard if present and equal to what is on\r\n      // the clipboard. See https://bugs.webkit.org/show_bug.cgi?id=19893.\r\n      editor.update(insertFragment(editor._latestEditorState, internalClipboard));\r\n      return;\r\n    }\r\n\r\n    // If there is html paste data, try to parse that.\r\n    if (html) {\r\n      var htmlFragment = DraftPasteProcessor.processHTML(html, editor.props.blockRenderMap);\r\n      if (htmlFragment) {\r\n        var contentBlocks = htmlFragment.contentBlocks,\r\n            entityMap = htmlFragment.entityMap;\r\n\r\n        if (contentBlocks) {\r\n          var htmlMap = BlockMapBuilder.createFromArray(contentBlocks);\r\n          editor.update(insertFragment(editor._latestEditorState, htmlMap, entityMap));\r\n          return;\r\n        }\r\n      }\r\n    }\r\n\r\n    // Otherwise, create a new fragment from our pasted text. Also\r\n    // empty the internal clipboard, since it's no longer valid.\r\n    editor.setClipboard(null);\r\n  }\r\n\r\n  if (textBlocks.length) {\r\n    var character = CharacterMetadata.create({\r\n      style: editorState.getCurrentInlineStyle(),\r\n      entity: getEntityKeyForSelection(editorState.getCurrentContent(), editorState.getSelection())\r\n    });\r\n\r\n    var currentBlockType = RichTextEditorUtil.getCurrentBlockType(editorState);\r\n\r\n    var textFragment = DraftPasteProcessor.processText(textBlocks, character, currentBlockType);\r\n\r\n    var textMap = BlockMapBuilder.createFromArray(textFragment);\r\n    editor.update(insertFragment(editor._latestEditorState, textMap));\r\n  }\r\n}\r\n\r\nfunction insertFragment(editorState, fragment, entityMap) {\r\n  var newContent = DraftModifier.replaceWithFragment(editorState.getCurrentContent(), editorState.getSelection(), fragment);\r\n  // TODO: merge the entity map once we stop using DraftEntity\r\n  // like this:\r\n  // const mergedEntityMap = newContent.getEntityMap().merge(entityMap);\r\n\r\n  return EditorState.push(editorState, newContent.set('entityMap', entityMap), 'insert-fragment');\r\n}\r\n\r\nfunction areTextBlocksAndClipboardEqual(textBlocks, blockMap) {\r\n  return textBlocks.length === blockMap.size && blockMap.valueSeq().every(function (block, ii) {\r\n    return block.getText() === textBlocks[ii];\r\n  });\r\n}\r\n\r\nmodule.exports = editOnPaste;"]},"metadata":{},"sourceType":"script"}